const express = require('express');
const line = require('@line/bot-sdk');
const tf = require('@tensorflow/tfjs-node');

const config = {
    channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
    channelSecret: process.env.CHANNEL_SECRET,
};

// ‚úÖ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠ class ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢
const classNames = [
    '‡∏´‡∏¢‡∏∏‡∏î (STOP)',
    '‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (Speed Limit)',
    '‡∏ó‡∏≤‡∏á‡∏°‡πâ‡∏≤‡∏•‡∏≤‡∏¢ (Pedestrian Crossing)',
    '‡∏´‡πâ‡∏≤‡∏°‡∏Å‡∏•‡∏±‡∏ö‡∏£‡∏ñ (U-Turn)',
    '‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß (Turn)',
    '‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß (No Turn)',
    '‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞ (Especially)',
    '‡∏°‡∏µ‡πÄ‡∏Å‡∏≤‡∏∞‡∏Å‡∏•‡∏≤‡∏á‡∏ñ‡∏ô‡∏ô (Dividers)',
    '‡∏ó‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πà‡∏¢‡∏á (Detour)'
];

const modelUrl = 'https://teachablemachine.withgoogle.com/models/kRF8-mnf8/model.json';

const app = express();
const client = new line.Client(config);
let model;

app.post('/webhook', line.middleware(config), (req, res) => {
    Promise.all(req.body.events.map(handleEvent))
        .then((result) => res.json(result))
        .catch((err) => {
            console.error(err);
            res.status(500).end();
        });
});

async function handleEvent(event) {
    if (event.type !== 'message' || event.message.type !== 'image') {
        return Promise.resolve(null);
    }

    try {
        const imageBuffer = await getImageBufferFromLine(event.message.id);

        // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏û‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ï‡∏≠‡∏ô train
        const imageTensor = tf.node.decodeImage(imageBuffer, 3)
            .resizeNearestNeighbor([224, 224])
            .toFloat()
            .div(tf.scalar(127.5))
            .sub(tf.scalar(1))
            .expandDims();

        const predictionResult = await model.predict(imageTensor).data();

        // ‚úÖ ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        let bestPrediction = { className: '‡πÑ‡∏°‡πà‡∏£‡∏π‡πâ‡∏à‡∏±‡∏Å', probability: 0 };
        for (let i = 0; i < predictionResult.length; i++) {
            if (predictionResult[i] > bestPrediction.probability) {
                bestPrediction.probability = predictionResult[i];
                bestPrediction.className = classNames[i];
            }
        }

        const confidence = Math.round(bestPrediction.probability * 100);

        // ‚úÖ ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô
        let replyText = '';
        if (confidence < 40) {
            replyText =
                `ü§î ‡∏â‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠‡∏õ‡πâ‡∏≤‡∏¢‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢‡∏Ñ‡πà‡∏∞\n` +
                `üì∏ ‡∏•‡∏≠‡∏á‡∏ñ‡πà‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡∏°‡∏≤‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞‡∏Ñ‡∏∞`;
        } else {
            replyText =
                `üîç *‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì:*\n\n` +
                `üì∏ ‡∏õ‡πâ‡∏≤‡∏¢‡∏à‡∏£‡∏≤‡∏à‡∏£: *${bestPrediction.className}*\n` +
                `üéØ ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥: ${confidence}%\n\n` +
                `‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏≠‡∏á‡∏ñ‡πà‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏î‡πâ‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö üôÇ`;
        }

        return client.replyMessage(event.replyToken, {
            type: 'text',
            text: replyText,
        });

    } catch (error) {
        console.error(error);
        return client.replyMessage(event.replyToken, {
            type: 'text',
            text: '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡πà‡∏∞ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ö‡∏≤‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á üò•',
        });
    }
}

function getImageBufferFromLine(messageId) {
    return new Promise((resolve, reject) => {
        client.getMessageContent(messageId)
            .then((stream) => {
                const chunks = [];
                stream.on('data', (chunk) => { chunks.push(chunk); });
                stream.on('error', (err) => { reject(err); });
                stream.on('end', () => { resolve(Buffer.concat(chunks)); });
            });
    });
}

async function startServer() {
    try {
        console.log('üì¶ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•...');
        model = await tf.loadLayersModel(modelUrl);
        console.log('‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
        const port = process.env.PORT || 3000;
        app.listen(port, () => {
            console.log(`üöÄ Bot is ready on port ${port}`);
        });
    } catch (error) {
        console.error('‚ùå ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:', error);
    }
}

startServer();
